<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Microcontroller</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <link
      rel="stylesheet"
      href="css/style.css"
      media="print"
      onload="this.media='all'"
    />
  </head>

  <body>
    <header>
      <nav class="nav-container">
        <div class="nav-content">
          <h1>Weather Monitoring System</h1>
          <div class="status-indicators">
            <span class="last-update" id="lastUpdated"></span>
          </div>
        </div>
      </nav>
    </header>

    <div class="container">
      <div class="controls">
        <div class="date-range-selector">
          <label for="startDate">Start Date:</label>
          <input type="datetime-local" id="startDate" />

          <label for="endDate">End Date:</label>
          <input type="datetime-local" id="endDate" />
        </div>
        <div class="status-bar">
          <button
            class="refresh-button"
            id="refreshButton"
            aria-label="Refresh data"
          >
            Refresh Data
          </button>
          <button
            class="unit-toggle"
            id="tempUnitToggle"
            aria-label="Toggle temperature unit"
          >
            °C
          </button>
          <div class="status-indicators">
            <span class="loading-indicator hidden" id="loadingIndicator">
              <div class="loading-spinner"></div>
              <span class="sr-only">Loading data...</span>
            </span>
          </div>
        </div>
      </div>

      <div class="chart-container">
        <canvas id="weatherChart" aria-label="Temperature chart"></canvas>
      </div>

      <div class="data-grid-container">
        <div id="dataContainer" class="data-grid">
          <!-- Data cards will be inserted here -->
        </div>
      </div>
    </div>

    <footer class="footer">
      <div class="footer-content">
        <p>&copy; 2024 Weather Monitoring System. All rights reserved.</p>
      </div>
    </footer>

    <script>
      // Constants and configurations
      const CONFIG = {
        API_URL: "http://localhost:8000/api/",
        // API_URL: 'https://localhost:7086/api/',
        REFRESH_INTERVAL: 30 * 1000,
        CHART_OPTIONS: {
          type: "line",
          responsive: true,
          plugins: { legend: { position: "top" } },
          scales: { y: { beginAtZero: false } },
        },
        API_TABLES: ["temperature", "temperature/latest"],
      };
      // Global variable to track the current API table index
      let currentApiTableIndex = 0;

      // State management
      const state = {
        chartInstance: null,
        currentSensor: "all",
        sensorData: {},
        selectedLocation: new URLSearchParams(window.location.search).get(
          "location"
        ),
        isCelsius: true,
      };

      // Add these utility functions
      function convertToFahrenheit(celsius) {
        return (celsius * 9) / 5 + 32;
      }

      function formatTemperature(value, isCelsius) {
        if (value == null) return "N/A";
        const temp = isCelsius ? value : convertToFahrenheit(value);
        const unit = isCelsius ? "°C" : "°F";
        return `${parseFloat(temp).toFixed(1)}${unit}`;
      }

      // DOM Elements cache
      const elements = {
        startDate: document.getElementById("startDate"),
        endDate: document.getElementById("endDate"),
        sensorGrid: document.getElementById("sensorGrid"),
        loadingIndicator: document.getElementById("loadingIndicator"),
        lastUpdated: document.getElementById("lastUpdated"),
        weatherChart: document.getElementById("weatherChart"),
      };

      // Utility functions
      const utils = {
        formatDateTime: (date) => {
          if (!date) return "N/A";
          const d = new Date(date);
          if (isNaN(d.getTime())) return "Invalid Date";

          return d.toLocaleString("en-GB", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false, // Use 24-hour format
          });
        },

        formatNumber: (value, unit, decimals = 1) => {
          return value != null
            ? `${parseFloat(value).toFixed(decimals)}${unit}`
            : "N/A";
        },

        formatDateForAPI: (date, includeTime = false) => {
          if (!date) return "";
          const d = new Date(date);
          if (isNaN(d.getTime())) return "";

          const year = d.getFullYear();
          const month = String(d.getMonth() + 1).padStart(2, "0");
          const day = String(d.getDate()).padStart(2, "0");
          const baseDate = `${year}-${month}-${day}`;

          if (includeTime) {
            const hours = String(d.getHours()).padStart(2, "0");
            const minutes = String(d.getMinutes()).padStart(2, "0");
            const seconds = String(d.getSeconds()).padStart(2, "0");
            return `${baseDate}T${hours}:${minutes}:${seconds}`;
          }

          return baseDate;
        },

        debounce: (func, wait) => {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        },
      };

      // Initialize application
      function initializeApp() {
        setupEventListeners();
        initializeDateInputs();
        fetchWeatherData();
        setInterval(fetchWeatherData, CONFIG.REFRESH_INTERVAL);
      }
      // Function to enable or disable the refresh button and handle loading indicator
      function toggleRefreshButtonState(isLoading) {
        const refreshButton = document.getElementById("refreshButton");
        const loadingIndicator = elements.loadingIndicator;

        refreshButton.disabled = isLoading;
        refreshButton.textContent = isLoading
          ? "Refreshing..."
          : "Refresh Data";
        loadingIndicator.classList.toggle("hidden", !isLoading);
      }

      // Refactored setupEventListeners function
      function setupEventListeners() {
        // Cache DOM elements for reuse
        const { startDate, endDate } = elements;
        const refreshButton = document.getElementById("refreshButton");

        startDate.addEventListener("change", handleDateChange);
        endDate.addEventListener("change", handleDateChange);

        refreshButton.addEventListener("click", async (e) => {
          e.preventDefault();
          toggleRefreshButtonState(true);

          try {
            // Update end date to current time
            const now = new Date();
            elements.endDate.value = formatDateForInput(now);

            await fetchWeatherData();
            // Update last refresh time
            elements.lastUpdated.textContent = `Last updated: ${new Date().toLocaleString()}`;
          } catch (error) {
            console.error("Refresh failed:", error);
            alert("Failed to refresh data. Please try again.");
          } finally {
            toggleRefreshButtonState(false);
          }
        });

        const tempUnitToggle = document.getElementById("tempUnitToggle");
        tempUnitToggle.addEventListener("click", () => {
          state.isCelsius = !state.isCelsius;
          tempUnitToggle.textContent = state.isCelsius ? "°C" : "°F";
          tempUnitToggle.classList.toggle("fahrenheit", !state.isCelsius);

          // Update chart with new temperature unit
          updateChart();

          // Update data cards if they exist
          if (state.sensorData) {
            displayData(state.sensorData);
          }
        });
      }
      // Format dates for datetime-local input (YYYY-MM-DDTHH:mm)
      const formatDateForInput = (date) => {
        return date.toLocaleString("sv").slice(0, 16).replace(" ", "T");
      };

      // Initialize date inputs
      function initializeDateInputs() {
        const now = new Date();
        const minDate = new Date("2025-01-01T00:00"); // Minimum allowed date

        // Set end date to current minute
        const endDate = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate(),
          now.getHours(),
          now.getMinutes()
        );

        // Create start date 24 hours before end date, but not before minDate
        const startDate = new Date(endDate);
        startDate.setHours(startDate.getHours() - 24);
        if (startDate < minDate) {
          startDate.setTime(minDate.getTime());
        }

        // Set values and constraints
        elements.startDate.min = formatDateForInput(minDate);
        elements.startDate.max = formatDateForInput(endDate);
        elements.endDate.min = formatDateForInput(minDate);
        elements.endDate.max = formatDateForInput(endDate);

        elements.startDate.value = formatDateForInput(startDate);
        elements.endDate.value = formatDateForInput(endDate);
      }

      // Data fetching
      async function fetchWeatherData() {
        try {
          elements.loadingIndicator.classList.remove("hidden");
          const startDate = new Date(elements.startDate.value);
          const endDate = new Date(elements.endDate.value);

          const apiUrl = buildApiUrl(
            0,
            startDate,
            endDate,
            state.selectedLocation
          );
          console.log(apiUrl);

          const response = await fetch(apiUrl);

          if (!response.ok) throw new Error("Network response was not ok");

          const data = await response.json();
          console.log(data);
          state.sensorData = {
            temp_sensor: data.data || [],
          };
          console.log(state.sensorData);

          updateChart();
          updatelastUpdatedTime();
        } catch (error) {
          console.error("Error:", error);
          showError("Failed to fetch weather data");
        } finally {
          elements.loadingIndicator.classList.add("hidden");
        }
      }

      // Function to build the API URL with the selected table index
      function buildApiUrl(tableIndex, startDate, endDate, location) {
        const timeDiff =
          (new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24);

        let startParam, endParam;
        let pageSize = 5000;

        if (timeDiff < 0) {
          throw new Error("End date cannot be before start date");
        } else {
          startParam = ["start_time", utils.formatDateForAPI(startDate, true)];
          endParam = ["end_time", utils.formatDateForAPI(endDate, true)];
        }

        // Update the global variable with the selected table index
        currentApiTableIndex = tableIndex;

        // Log the selected API table index for debugging
        // console.log(`Using API_TABLE index: ${currentApiTableIndex}`);

        const url = new URL(CONFIG.API_TABLES[0], CONFIG.API_URL);
        url.searchParams.append(startParam[0], startParam[1]);
        url.searchParams.append(endParam[0], endParam[1]);
        url.searchParams.append("page", "1");
        url.searchParams.append("page_size", pageSize.toString());

        if (location) {
          url.searchParams.append("location", location);
        }

        return url.toString();
      }

      function updateChart() {
        const ctx = elements.weatherChart.getContext("2d");

        if (state.chartInstance) {
          state.chartInstance.destroy();
        }

        const datasets = [];
        const baseColor = "hsl(200, 70%, 50%)";
        const lightColor = "hsla(200, 70%, 70%, 0.4)";

        try {
          const chartData = [];
          Object.entries(state.sensorData).forEach(([nodeId, data]) => {
            data.forEach((item) => {
              const tempValue = state.isCelsius
                ? item.temperature_value
                : convertToFahrenheit(item.temperature_value);

              chartData.push({
                x: new Date(item.reading_time),
                y: tempValue,
              });
            });
          });

          datasets.push({
            label: `Temperature Sensor DS1621 (${
              state.isCelsius ? "°C" : "°F"
            })`,
            data: chartData,
            borderColor: baseColor,
            backgroundColor: lightColor,
            tension: 0.2,
            borderWidth: 2,
            pointStyle: "circle",
            pointRadius: 5,
            pointHoverRadius: 10,
            pointHoverBorderWidth: 2,
            pointHoverBorderColor: baseColor,
            fill: false,
          });

          state.chartInstance = new Chart(ctx, {
            type: "line",
            data: { datasets },
            options: {
              responsive: true,
              scales: {
                x: {
                  type: "time",
                  time: {
                    unit: "minute",
                    displayFormats: {
                      minute: "dd-MM-yyyy HH:mm",
                      hour: "dd-MM-yyyy HH:mm",
                      day: "dd-MM-yyyy",
                    },
                  },
                  title: {
                    display: true,
                    text: "Time",
                  },
                },
                y: {
                  title: {
                    display: true,
                    text: `Temperature (${state.isCelsius ? "°C" : "°F"})`,
                  },
                },
              },
              plugins: {
                title: {
                  display: true,
                  text: "Temperature Readings",
                },
                tooltip: {
                  mode: "index",
                  intersect: false,
                },
              },
            },
          });
        } catch (error) {
          console.error("Error updating chart:", error);
        }
      }

      // Error handling
      function showError(message) {
        const errorContainer =
          elements.sensorGrid || document.createElement("div");
        if (!elements.sensorGrid) {
          errorContainer.className = "error-message";
          document.querySelector(".container").appendChild(errorContainer);
        }
        errorContainer.innerHTML = `<div class="error-message">${message}</div>`;
      }

      // Date validation
      const handleDateChange = utils.debounce(() => {
        const startDate = new Date(elements.startDate.value);
        const endDate = new Date(elements.endDate.value);

        if (startDate > endDate) {
          alert("Start date cannot be after end date");
          return;
        }
        fetchWeatherData();
      }, 300);

      function updatelastUpdatedTime() {
        elements.lastUpdated.textContent = `Last updated: ${new Date().toLocaleString()}`;
      }

      const displayData = (data) => {
        const container = document.getElementById("dataContainer");

        document.getElementById(
          "lastUpdated"
        ).textContent = `Last updated: ${new Date().toLocaleString()}`;
      };

      // Initialize the application
      document.addEventListener("DOMContentLoaded", initializeApp);
    </script>
  </body>
</html>